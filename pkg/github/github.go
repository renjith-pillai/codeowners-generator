package github

import (
	"context"
	"fmt"
	"net/http"
	"sort"
	"strings"
	"time"

	"github.com/google/go-github/v63/github"
)

func NewClient(githubServerURL, githubToken string) (*github.Client, error) {
	ts := github.TokenSource{Token: githubToken}
	tc := github.NewClient(github.ClientOptions{
		HTTPClient: &http.Client{Transport: http.DefaultTransport},
		BaseURL:    githubServerURL,
		UserAgent:  "codeowners-generator",
	})
	tc.Transport = http.DefaultTransport
	tc.RateLimit = nil
	tc.UserAgent = "codeowners-generator"
	return tc, nil
}

func GetTopContributors(ctx context.Context, client *github.Client, owner, repo string, duration time.Duration) ([]github.User, error) {
	// Fetch commit activity for the specified duration
	since := time.Now().Add(-duration)
	commits, _, err := client.Activity.ListCommits(ctx, owner, repo, nil, &github.CommitsListOptions{
		Since: since.Format("2006-01-02T15:04:05Z"),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch commits: %w", err)
	}

	// Group contributors by login and count their commits
	contributorCounts := make(map[string]int)
	for _, commit := range commits {
		if commit.Author != nil {
			contributorCounts[commit.Author.Login]++
		}
	}

	// Sort contributors by commit count in descending order
	contributors := make([]github.User, 0, len(contributorCounts))
	for login, count := range contributorCounts {
		contributors = append(contributors, github.User{Login: &login, Contributions: &count})
	}
	sort.Slice(contributors, func(i, j int) bool {
		return contributors[i].Contributions > contributors[j].Contributions
	})

	return contributors[:codeReviewersCount], nil
}

func GenerateCodeowners(topContributors []github.User) string {
	var codeownersContent strings.Builder
	codeownersContent.WriteString("# This file is automatically generated by codeowners-generator\n")
	for _, contributor := range topContributors {
		codeownersContent.WriteString(fmt.Sprintf("%s/*\n\t@%s\n", contributor.Login, contributor.Login))
	}
	return codeownersContent.String()
}

func FetchExistingCodeowners(ctx context.Context, client *github.Client, owner, repo string) (string, error) {
	existingCodeowners, _, err := client.Repositories.DownloadContents(ctx, owner, repo, "CODEOWNERS", nil)
	if err != nil && !strings.Contains(err.Error(), "not found") {
		return "", fmt.Errorf("failed to fetch existing CODEOWNERS: %w", err)
	}
	if existingCodeowners == nil {
		return "", nil
	}
	return string(existingCodeowners), nil
}

func CompareCodeowners(generatedCodeowners, existingCodeowners string) bool {
	return !strings.EqualFold(existingCodeowners, generatedCodeowners)
}

func CreateBranchAndSubmitPullRequest(ctx context.Context, client *github.Client, owner, repo string, codeownersContent string) error {
	branchName := fmt.Sprintf("update-codeowners-%d", time.Now().Unix())
	ref := github.Reference{Ref: &branchName}
	_, _, err := client.Git.CreateRef(ctx, owner, repo, "heads/"+branchName, ref)
	if err != nil {
		return fmt.Errorf("failed to create new branch: %w", err)
	}

	// Create a new commit
	commitMessage := "Update CODEOWNERS based on top contributors"
	tree, err := client.Git.CreateTree(ctx, owner, repo, "", &github.Tree{
		Base:    nil,
		Mode:    "100644",
		Type:    "blob",
		Path:    "CODEOWNERS",
		Content: &codeownersContent,
	})
	if err != nil {
		return fmt.Errorf("failed to create new tree: %w", err)
	}

	parentCommit, _, err := client.Repositories.GetCommit(ctx, owner, repo, "master")
	if err != nil {
		return fmt.Errorf("failed to get parent commit: %w", err)
	}

	commit := &github.Commit{
		Message: &commitMessage,
		Tree:    tree,
		Parent:  []string{parentCommit.SHA},
	}

	_, _, err = client.Git.CreateCommit(ctx, owner, repo, commit)
	if err != nil {
		return fmt.Errorf("failed to create new commit: %w", err)
	}

	// Create a pull request
	pr := &github.PullRequest{
		Title: &commitMessage,
		Head:  &branchName,
		Base:  "master",
		Body:  &commitMessage,
	}
	_, _, err = client.PullRequests.Create(ctx, owner, repo, pr)
	if err != nil {
		return fmt.Errorf("failed to create pull request: %w", err)
	}

	return nil
}
